
#include "Sorted.h"
#include <cstring>
#include <iterator>
#include <iostream>
#include <array>
#include "clean.h"
using namespace std;



Sorted::Sorted():UnSorted(){}  //Χρησιμοποιείται ο κατασκευαστής της κλάσης UnSorted


//Αυτή η συνάρτηση δέχεται ως όρισμα μια συμβολοσειρά και την εισάγει στο πίνακα

void Sorted::insert_(string word)
{
  clean(word);
  if (search_(0,pointer-1,word)) //αρχικά αναζητείται η λέξη με τη βοήθεια της συνάρτησης search και εάν υπάρχει ήδη
  {
    data[found].count_++;  //τότε αυξάνεται κατά 1 το πλήθος του στοιχείου στο οποίο βρέθηκε η λέξη
  }else                   //αλλιώς
  {
    for (int i=pointer; i>found; i--)
    {
      data[i]=data[i-1];      //όλα τα στοιχεία από το found (το found είναι η θέση στην οποία πρέπει να εισαχθεί το νέο στοιχείο) και μετά μετακινούνται μία θέση προς τα δεξιά
    }
    data[found].w=word;     //στη κενή θέση που δημιουργείται εισάγεται η λέξη
    data[found].count_=1;    //και το πλήθος της
    pointer++;              //αυξάνεται ο pointer για να δείχνει στην επόμενη κενή θέση του πίνακα
    if (pointer==size_)   //αν το pointer είναι ίσο με το size τότε
      moreMemory();      //χρησιμοποιείται η μέθοδος moreMemory() για την αύξηση της μνήμης
  }
  return;
}

//Αυτή η μέθοδος δέχεται ως όρισμα μια συμβολοσειρά, τη θέση του πρώτου (first) και του τελευταίου στοιχείου (last) του πίνακα data και την αναζητά αναδρομικά (δυαδική αναζήτηση)

bool Sorted::search_(int first,int last,string word)
{
  int meso;  //το μέσο του πίνακα
	if (first<=last)  //αν το πρώτο στοιχείο είναι μικρότερο του τελευταίου τοτε
	{
		meso = (first+last)/2;   //εύρεση του μέσου
    if(word.compare(data[meso].w)==0) //αν η λέξη που αναζητείται είναι ίδια με αυτή του στοιχείου που βρίσκεται στο μέσο
    {
      found=meso; //τότε καταχωρείται στο found το μέσο
      return true; //και επιστρέφεται true
    }
		if (word.compare(data[meso].w)<0)  //αν η λέξη είναι μικρότερη από αυτή του στοιχείου που βρίσκεται στο μέσο
    {
      found=meso;   //τότε καταχωρείται στο found το μέσο (εάν η λέξη δεν υπάρχει τότε η τελευταία τιμή που θα πάρει το found θα είναι η θέση στην οποία πρέπει να μπει η λέξη κατά την εισαγωγή )
		  return search_(first,meso-1,word);  //αναζητείται η λέξη στον αριστερό υποπίνακα
    }
		else if(word.compare(data[meso].w)>0)//αλλιώς αν η λέξη είναι μεγαλύτερη από αυτή του στοιχείου που βρίσκεται στο μέσο
    {
      found=meso+1; //τότε καταχωρείται στο found το μέσο+1 (εάν η λέξη δεν υπάρχει τότε η τελευταία τιμή που θα πάρει το found θα είναι η θέση στην οποία πρέπει να μπει η λέξη κατά την εισαγωγή )
      return search_(meso+1,last,word);  //αναζητείται η λέξη στο δεξιό υποπίνακα
    }
	}
	return false; //εάν η λέξη δε βρεθεί τότε επιστρέφεται false
}


//Αυτή η μέθοδος παίρνει ως όρισμα μια συμβολοσειρά, την αναζητά και επιστρέφει true αν υπάρχει στο πίνακα και false αν δεν υπάρχει

bool Sorted::search_(string word)
 {
   clean(word);
   if (search_(0,getSize(),word))
   {
     return true;
   }
   return false;
 }


//Αυτή η μέθοδος δέχεται σαν όρισμα μια συμβολοσειρά και την διαγράφει από τον πίνακα

void Sorted::delete_(string word)
{
  clean(word);
  if (search_(0,pointer-1,word))   //αρχικά αναζητείται η λέξη με τη βοήθεια της μεθόδου search και εάν υπάρχει τότε
  {
    if (data[found].count_>1)  //εάν το πλήθος της λέξης είναι μεγαλύτερο από 1 τότε
    {
      data[found].count_--;   //απλά μειώνεται κατά 1
    }
    else
    {
      for (int i=found; i<pointer; i++) //όλα τα στοιχεία από το found και μετά
      {
        data[i]=data[i+1];              //μετακινούνται μία θέση προς τα αριστερά
      }
      lessMemory();  //χρησιμοποιείται η μέθοδος lessMemory() για την μείωση της μνήμης
    }
  }
  else
  {
    cout<<"this word not exist"<<endl; //εάν η λέξη δεν υπάρχει τότε εμφανίζεται κατάλληλο μύνημα
  }
}
